<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>生词字谜搜寻</title>
    <style>
        :root {
            --select-color: #f1c40f; /* 选取中的颜色 (黄色) */
            --found-color: #2ecc71;  /* 找到后的颜色 (绿色) */
            --bg-color: #2c3e50;
        }

        body {
            font-family: "微软正黑体", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            user-select: none; /* 禁止反白文字 */
            touch-action: none; /* 防止手机滑动页面 */
        }

        h1 { color: #333; margin-bottom: 10px; }

        /* 游戏主容器：左右排列 */
        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* 字谜网格区 */
        #grid-area {
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            position: relative;
            cursor: crosshair;
        }

        .row {
            display: flex;
        }

        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #555;
            border: 1px solid #eee;
            box-sizing: border-box;
            transition: background 0.1s;
        }

        /* 选取状态 */
        .cell.selected {
            background-color: var(--select-color);
            color: white;
            border-radius: 50%;
        }

        /* 找到状态 */
        .cell.found {
            background-color: var(--found-color);
            color: white;
            animation: pop 0.3s;
        }

        /* 右侧单词列表 */
        .word-list {
            background: white;
            padding: 20px;
            border-radius: 10px;
            min-width: 200px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .word-list h3 { margin-top: 0; border-bottom: 2px solid #eee; padding-bottom: 10px;}

        .word-item {
            font-size: 1.2em;
            margin-bottom: 8px;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .word-item.done {
            text-decoration: line-through;
            color: #bbb;
        }
        
        .word-item.done::after {
            content: "✔";
            color: var(--found-color);
        }

        /* 控制按钮 */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }
        button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background-color: var(--bg-color);
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover { opacity: 0.9; }

        /* 画线 Canvas (浮在网格上) */
        #canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* 让点击穿透到下方的 div */
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* 手机版调整 */
        @media (max-width: 700px) {
            .cell { width: 32px; height: 32px; font-size: 1em; }
            .game-container { flex-direction: column-reverse; align-items: center; }
            .word-list { width: 90%; }
        }
    </style>
</head>
<body>

    <h1>生词字谜搜寻</h1>
    <p style="color:#666; margin-top:0;">(请在网格中滑动找出右侧的单字)</p>

    <div class="game-container">
        <div class="word-list">
            <h3>寻找清单:</h3>
            <div id="words-to-find"></div>
        </div>

        <div id="grid-area">
            </div>
    </div>

    <div class="controls">
        <button onclick="initGame()">重新生成 (刷新)</button>
    </div>

    <script src="words.js"></script>

    <script>
        // --- 设定 ---
        const GRID_SIZE = 10; // 网格大小 10x10
        const DIRECTIONS = [
            [0, 1],  // 横向 (向右)
            [1, 0],  // 直向 (向下)
            [1, 1],  // 斜向 (右下)
            [-1, 1]  // 斜向 (右上) - 增加难度可开启
        ];
        
        // 用来填补空白的随机中文字 (常用字库)
        const FILLER_CHARS = "的一是在不了有和人这中大为上个国我以要他时来用们生到作地于出就分对成会可主发年动同工也能下过子说产种面而方后多定行学法所民得经十三之进着等部度家更完天";

        // --- 变数 ---
        let gridData = [];
        let placedWords = []; // 实际成功放入的单字
        let isSelecting = false;
        let startCell = null;
        let endCell = null;
        let selectionPath = []; // 记录选取路径上的格子

        // DOM
        const gridArea = document.getElementById('grid-area');
        const wordListEl = document.getElementById('words-to-find');

        if (typeof wordData === 'undefined') {
            alert("找不到 words.js");
        }

        // --- 核心逻辑: 游戏初始化 ---
        function initGame() {
            // 1. 清空状态
            gridData = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(''));
            placedWords = [];
            gridArea.innerHTML = '';
            wordListEl.innerHTML = '';

            // 2. 选取单字 (取前10个，或全部)
            // 先洗牌，增加随机性
            let shuffled = [...wordData].sort(() => 0.5 - Math.random());
            let targetWords = shuffled.slice(0, 12); // 最多放12个，以免塞不下

            // 3. 尝试放入单字
            targetWords.forEach(item => {
                placeWord(item.word);
            });

            // 4. 填补空白并绘制网格
            fillBlanksAndRender();

            // 5. 显示右侧列表 (显示 中文生词)
            // 如果您希望显示英文让学生找中文，把 `w.word` 改成 `w.meaning` 即可
            placedWords.forEach(w => {
                let div = document.createElement('div');
                div.className = 'word-item';
                div.id = `list-${w}`;
                div.innerText = w; 
                div.dataset.word = w;
                wordListEl.appendChild(div);
            });
        }

        // --- 逻辑: 放置单字 (Backtracking 概念) ---
        function placeWord(word) {
            // 尝试 50 次随机放置，如果都失败就放弃这个字
            let attempts = 0;
            while (attempts < 50) {
                const direction = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];
                const startRow = Math.floor(Math.random() * GRID_SIZE);
                const startCol = Math.floor(Math.random() * GRID_SIZE);

                if (canPlace(word, startRow, startCol, direction)) {
                    // 真的放进去
                    for (let i = 0; i < word.length; i++) {
                        gridData[startRow + i * direction[0]][startCol + i * direction[1]] = word[i];
                    }
                    placedWords.push(word);
                    return true;
                }
                attempts++;
            }
            return false;
        }

        // 检查是否能放
        function canPlace(word, r, c, dir) {
            for (let i = 0; i < word.length; i++) {
                const nr = r + i * dir[0];
                const nc = c + i * dir[1];

                // 检查边界
                if (nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE) return false;

                // 检查重迭 (如果该格是空的，或是跟目前字母一样，就可以)
                const cellChar = gridData[nr][nc];
                if (cellChar !== '' && cellChar !== word[i]) return false;
            }
            return true;
        }

        // --- 逻辑: 渲染画面 ---
        function fillBlanksAndRender() {
            for (let r = 0; r < GRID_SIZE; r++) {
                let rowDiv = document.createElement('div');
                rowDiv.className = 'row';
                for (let c = 0; c < GRID_SIZE; c++) {
                    // 填补空白
                    if (gridData[r][c] === '') {
                        gridData[r][c] = FILLER_CHARS[Math.floor(Math.random() * FILLER_CHARS.length)];
                    }

                    // 建立 DOM
                    let cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = gridData[r][c];
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    // 鼠标/触控事件
                    cell.addEventListener('mousedown', handleStart);
                    cell.addEventListener('mouseenter', handleMove);
                    cell.addEventListener('touchstart', handleTouchStart, {passive: false});
                    
                    rowDiv.appendChild(cell);
                }
                gridArea.appendChild(rowDiv);
            }
            
            // 全局结束事件
            document.addEventListener('mouseup', handleEnd);
            document.addEventListener('touchend', handleEnd);
        }

        // --- 互动事件处理 ---
        
        function handleStart(e) {
            isSelecting = true;
            startCell = e.target;
            highlightCells(startCell, startCell);
        }

        function handleMove(e) {
            if (!isSelecting) return;
            endCell = e.target;
            highlightCells(startCell, endCell);
        }

        // 手机触控模拟
        function handleTouchStart(e) {
            e.preventDefault(); // 防止卷动
            let touch = e.touches[0];
            let target = document.elementFromPoint(touch.clientX, touch.clientY);
            if(target && target.classList.contains('cell')) {
                handleStart({target: target});
            }
        }
        
        // 手机触控移动 (需要绑在 gridArea 上)
        gridArea.addEventListener('touchmove', function(e) {
            if (!isSelecting) return;
            e.preventDefault();
            let touch = e.touches[0];
            let target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (target && target.classList.contains('cell')) {
                handleMove({target: target});
            }
        }, {passive: false});


        function handleEnd() {
            if (!isSelecting) return;
            isSelecting = false;

            // 检查是否选中正确单字
            const selectedWord = selectionPath.map(cell => cell.textContent).join('');
            
            // 支持反向选取 (例如从下往上拉)
            const reversedWord = selectedWord.split('').reverse().join('');

            if (checkWord(selectedWord) || checkWord(reversedWord)) {
                // 答对了：标记为永久绿色
                selectionPath.forEach(cell => cell.classList.add('found'));
                
                // 播放音效 (选用)
                // speak(checkWord(selectedWord) ? selectedWord : reversedWord);
            }

            // 清除黄色选取状态
            document.querySelectorAll('.cell.selected').forEach(el => el.classList.remove('selected'));
            selectionPath = [];
            startCell = null;
            endCell = null;
        }

        function highlightCells(start, end) {
            // 清除旧的选取
            document.querySelectorAll('.cell.selected').forEach(el => el.classList.remove('selected'));
            selectionPath = [];

            const r1 = parseInt(start.dataset.r);
            const c1 = parseInt(start.dataset.c);
            const r2 = parseInt(end.dataset.r);
            const c2 = parseInt(end.dataset.c);

            // 计算方向向量
            let dr = r2 - r1;
            let dc = c2 - c1;

            // 判断是否为直线 (横、直、斜)
            if (dr === 0 && dc === 0) {
                // 同一格
                start.classList.add('selected');
                selectionPath.push(start);
                return;
            }

            // 简单正规化向量 (例如 (0, 5) 变成 (0, 1))
            const steps = Math.max(Math.abs(dr), Math.abs(dc));
            
            // 检查是否为合法的 8 方向 (dx, dy 必须相等或者是 0)
            if (Math.abs(dr) !== 0 && Math.abs(dc) !== 0 && Math.abs(dr) !== Math.abs(dc)) {
                return; // 不是直线，不画
            }

            const stepR = dr / steps;
            const stepC = dc / steps;

            for (let i = 0; i <= steps; i++) {
                let nr = r1 + Math.round(i * stepR);
                let nc = c1 + Math.round(i * stepC);
                
                // 找到对应的 DOM
                let cell = document.querySelector(`.cell[data-r='${nr}'][data-c='${nc}']`);
                if (cell) {
                    cell.classList.add('selected');
                    selectionPath.push(cell);
                }
            }
        }

        function checkWord(word) {
            // 检查是否在我们的列表中
            if (placedWords.includes(word)) {
                const listEl = document.getElementById(`list-${word}`);
                if (listEl && !listEl.classList.contains('done')) {
                    listEl.classList.add('done'); // 划掉清单
                    
                    // 检查是否全部完成
                    if (document.querySelectorAll('.word-item.done').length === placedWords.length) {
                        setTimeout(() => alert("恭喜！所有单字都找到了！"), 300);
                    }
                    return true;
                }
            }
            return false;
        }

        // 语音功能 (选用)
        function speak(text) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel(); 
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'zh-TW';
                window.speechSynthesis.speak(utterance);
            }
        }

        // 启动
        initGame();

    </script>
</body>
</html>